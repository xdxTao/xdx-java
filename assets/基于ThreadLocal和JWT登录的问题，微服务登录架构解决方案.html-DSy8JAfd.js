import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as e,b as a}from"./app-BcAKAKCF.js";const l="/assets/1901_7-DWjLls_H.png",n={},t=a(`<br><p><a href="https://www.bilibili.com/video/BV1f3411G7xk" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1f3411G7xk</a></p><br><p>公司之前是以JWT + ThreadLocal 做的登录系统，在使用的过程发现了如下的问题，下面我们一起来看看，后面也会给出更好的解决方案。</p><br><h2 id="一、基于jwt-threadlocal实现登录" tabindex="-1"><a class="header-anchor" href="#一、基于jwt-threadlocal实现登录"><span>一、基于JWT + ThreadLocal实现登录</span></a></h2><br><h3 id="_1-1、jwt" tabindex="-1"><a class="header-anchor" href="#_1-1、jwt"><span>1-1、JWT</span></a></h3><p>所谓的JWT是 <code>json web token</code> 的缩写，你可以理解成把一个数据进行一系列的加密后生成的一个字符串，所以你也可以把它解密成原本的数据。</p><br><h3 id="_1-2、threadlocal" tabindex="-1"><a class="header-anchor" href="#_1-2、threadlocal"><span>1-2、ThreadLocal</span></a></h3><p>这个可能很多人听过，但却很少人用过，其实很简单，在多线程的情况下，如果你不想用同步的方式解决就可以用ThreadLocal线程本地变量来解决并发的问题。</p><p>你可以理解成它是一个特殊的map，它的key就是线程本身，value就是你想存储的数据。</p><br><h3 id="_1-3、实现思路" tabindex="-1"><a class="header-anchor" href="#_1-3、实现思路"><span>1-3、实现思路</span></a></h3><p>实现起来很简单，一个登录接口生成<code>token</code>，一个拦截器，每次解析token放入当前线程的 <code>threadLocal</code>，然后在方法里面随时随地的获取当前用户信息了。</p><p>很简单，只要我们定义一个类，给它设置静态方法，就OK了。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> UserSessionContext</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> ThreadLocal</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;">UserSessionVO</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> userSessionVOThreadLocal </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> ThreadLocal</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> set</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">UserSessionVO</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> userSessionVO</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        userSessionVOThreadLocal</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(userSessionVO);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> UserSessionVO</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> get</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> userSessionVOThreadLocal</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> remove</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        userSessionVOThreadLocal</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">remove</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><br> <br></p><h2 id="二、存在的问题" tabindex="-1"><a class="header-anchor" href="#二、存在的问题"><span>二、存在的问题</span></a></h2><br><h3 id="_2-1、内存泄漏" tabindex="-1"><a class="header-anchor" href="#_2-1、内存泄漏"><span>2-1、内存泄漏</span></a></h3><p>所谓内存泄漏就是很多无用的数据，也无法被回收。</p><p>在Java里面，有四种引用</p><ul><li>强引用：被强引用的对象不会被回收。（new 的方式就是强引用）</li><li>软应用：被软引用的对象只有内存不足的时候才会被回收</li><li>弱引用：被弱引用的对象下次垃圾回收的时候一定会被回收</li><li>虚引用：虚引用和垃圾回收没有什么关系，只是在回收的时候会得到一个系统通知</li></ul><p>我们的线程并不是频繁创建的，是有一个工作线程池的，当一个线程处理完后就被放回了线程池，下一个线程又调用 <code>set</code>方法设置数据，而之前的数据并没有被释放，因为是<code>new</code>创建的所以还有一个<code>强引用</code>指向它，导致它无法被使用却也不能被回收。</p><br><p><strong>解决办法:</strong> 在拦截器的后处理里面调用threadlocal的<code>remove</code>方法删除即可</p><br><h3 id="_2-2、后面的请求使用了前面的登录数据" tabindex="-1"><a class="header-anchor" href="#_2-2、后面的请求使用了前面的登录数据"><span>2-2、后面的请求使用了前面的登录数据</span></a></h3><p>因为在最开始的方案里面，没有在拦截器后处理去 <code>remove</code> ThreadLocal里面的数据，而又存在某些请求既可以登陆又可以不登陆，就导致后面的请求使用了之前的登陆数据，导致数据异常。</p><br><h3 id="_2-3、多个系统权限问题" tabindex="-1"><a class="header-anchor" href="#_2-3、多个系统权限问题"><span>2-3、多个系统权限问题</span></a></h3><p>一般系统都是有用户端和管理端，我们在管理端可以修改用户权限，修改后我们同时更新JWT，这样访问管理端是没有问题。</p><p>但是在用户端就不行，没办法清除数据就导致用户端的权限不一致了。</p><br><h3 id="_2-4、其它" tabindex="-1"><a class="header-anchor" href="#_2-4、其它"><span>2-4、其它</span></a></h3><p>其实现在大部分都是使用redis做数据存储，token一个随机字符串就搞定了，但有时候我们没必要或者不想引入新的技术。另外本地内存肯定是要更快的。</p><p>上述的问题也都有办法可以解决的，想一想？在逻辑上都可以解决的。</p><br><h2 id="三、完美的解决方案" tabindex="-1"><a class="header-anchor" href="#三、完美的解决方案"><span>三、完美的解决方案</span></a></h2><p>设想一个这样的场景，我们后台服务有30+，并不是所有接口都需要进行权限校验（大部分接口是需要进行权限校验的），你应当如何设置一个完美的结局方案呢？</p><p>思想还是和之前一样，生成一个token（uuid/jwt），然后一个拦截器进行拦截，再来一个自定义注解判断是否需要拦截。</p><p>不同在于，我们把这个生成token、解析token的步骤抽离出来，做成一个公共包，这样每个需要用到的服务直接引入，然后在需要拦截的方法加一个注解就好了。</p><br><p><strong>服务架构图</strong></p><figure><img src="`+l+'" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><br><h3 id="_3-1、common" tabindex="-1"><a class="header-anchor" href="#_3-1、common"><span>3-1、common</span></a></h3><p>关于登录部分一些公共的部分就放在这里，比如登录拦截注解、自定义异常、返回的<code>ResponseObj</code>类(就是一个自定义返回值里面有 code、data、message)</p><p>之所以单独拎出来也是为了好维护，因为我们的<code>client</code> 和 <code>service</code> 都要引入，后续也可能会对基础包里面新增修改啥的，这样就只需要维护一个公共包就好了，不用修改两处。</p><br><h3 id="_3-2、service" tabindex="-1"><a class="header-anchor" href="#_3-2、service"><span>3-2、service</span></a></h3><p>这个服务很简单，但是很重要，它是一个独立运行提供http服务的服务。</p><p>它提供两个主要的接口</p><ol><li>生成token，你之前的token怎么生成，它这个就怎么生成，一样的</li><li>解析token，我们无非是获取到了token然后再去把它转换成用户信息（不管是JWT还是存入redis都一样）</li></ol><br><h3 id="_3-3、client" tabindex="-1"><a class="header-anchor" href="#_3-3、client"><span>3-3、client</span></a></h3><p>这个是很巧妙的一部分，我们把client使用 <code>mvn deploy</code> 命令推到远程仓库，这样谁需要使用，直接在pom里面引入就好了。</p><p>我们项目引入了 client，而client引入了 common，所以我们项目也可以使用自定义注解，只需要在需要拦截的地方加入自定义登录拦截注解就好了。</p><p>把之前的拦截器复制到client里面，对于解析token的地方改成使用http调用service服务（当然也可以使用openFeign这样的方式调用）。</p><p>底包有一个很重要的思想：<strong>引入就使用，如果不使用就不要引入，所以我们需要在自动注入里面直接配置好注入这个拦截器。</strong></p><br><h2 id="四、其它" tabindex="-1"><a class="header-anchor" href="#四、其它"><span>四、其它</span></a></h2><br><h3 id="_4-1、代码" tabindex="-1"><a class="header-anchor" href="#_4-1、代码"><span>4-1、代码</span></a></h3><p>因为这个涉及到公司源码，不方面公开，原理就是这样，可以根据原理搭建一个，前提准备知识是关于 starter 的构建，可以看看这个 <a href="https://blog.csdn.net/Tomwildboar/article/details/122901248" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/Tomwildboar/article/details/122901248</a></p><br><h3 id="_4-2、关于单点登录" tabindex="-1"><a class="header-anchor" href="#_4-2、关于单点登录"><span>4-2、关于单点登录</span></a></h3><p>在写这个文章的时候，突然想到单点登录，毕竟都是解决登录问题嘛，有什么区别呢？</p><ul><li>单点登录：单点登录解决的是多个系统使用同一套账号体系来登录。</li><li>上面登录：今天介绍的登录是为了解决多个服务之间的鉴权，比如我们现在一个系统40多个服务，服务之间调用，以及前后端登录交互。</li></ul><br><p><a href="https://blog.csdn.net/Tomwildboar/article/details/116046354" target="_blank" rel="noopener noreferrer">Java进阶之单点登录详解</a></p>',73),h=[t];function r(p,d){return e(),s("div",null,h)}const k=i(n,[["render",r],["__file","基于ThreadLocal和JWT登录的问题，微服务登录架构解决方案.html.vue"]]),E=JSON.parse('{"path":"/19%E5%9C%BA%E6%99%AF%E9%A2%98/01%E5%8A%9F%E8%83%BD%E5%AE%9E%E8%B7%B5/%E5%9F%BA%E4%BA%8EThreadLocal%E5%92%8CJWT%E7%99%BB%E5%BD%95%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%99%BB%E5%BD%95%E6%9E%B6%E6%9E%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html","title":"【初】基于ThreadLocal和JWT登录的问题，微服务登录架构解决方案","lang":"zh-CN","frontmatter":{"title":"【初】基于ThreadLocal和JWT登录的问题，微服务登录架构解决方案","shortTitle":"【初】微服务登录架构解决方案","index":true,"date":"2022-05-22T19:28:29.000Z","category":["初级","视频讲解"],"description":"https://www.bilibili.com/video/BV1f3411G7xk 公司之前是以JWT + ThreadLocal 做的登录系统，在使用的过程发现了如下的问题，下面我们一起来看看，后面也会给出更好的解决方案。 一、基于JWT + ThreadLocal实现登录 1-1、JWT 所谓的JWT是 json web token 的缩写，你...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/19%E5%9C%BA%E6%99%AF%E9%A2%98/01%E5%8A%9F%E8%83%BD%E5%AE%9E%E8%B7%B5/%E5%9F%BA%E4%BA%8EThreadLocal%E5%92%8CJWT%E7%99%BB%E5%BD%95%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%99%BB%E5%BD%95%E6%9E%B6%E6%9E%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"}],["meta",{"property":"og:site_name","content":"小道仙Java笔记"}],["meta",{"property":"og:title","content":"【初】基于ThreadLocal和JWT登录的问题，微服务登录架构解决方案"}],["meta",{"property":"og:description","content":"https://www.bilibili.com/video/BV1f3411G7xk 公司之前是以JWT + ThreadLocal 做的登录系统，在使用的过程发现了如下的问题，下面我们一起来看看，后面也会给出更好的解决方案。 一、基于JWT + ThreadLocal实现登录 1-1、JWT 所谓的JWT是 json web token 的缩写，你..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"小道仙97"}],["meta",{"property":"article:published_time","content":"2022-05-22T19:28:29.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"【初】基于ThreadLocal和JWT登录的问题，微服务登录架构解决方案\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-05-22T19:28:29.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小道仙97\\",\\"url\\":\\"https://java.xdx97.com\\"}]}"]]},"headers":[{"level":2,"title":"一、基于JWT + ThreadLocal实现登录","slug":"一、基于jwt-threadlocal实现登录","link":"#一、基于jwt-threadlocal实现登录","children":[{"level":3,"title":"1-1、JWT","slug":"_1-1、jwt","link":"#_1-1、jwt","children":[]},{"level":3,"title":"1-2、ThreadLocal","slug":"_1-2、threadlocal","link":"#_1-2、threadlocal","children":[]},{"level":3,"title":"1-3、实现思路","slug":"_1-3、实现思路","link":"#_1-3、实现思路","children":[]}]},{"level":2,"title":"二、存在的问题","slug":"二、存在的问题","link":"#二、存在的问题","children":[{"level":3,"title":"2-1、内存泄漏","slug":"_2-1、内存泄漏","link":"#_2-1、内存泄漏","children":[]},{"level":3,"title":"2-2、后面的请求使用了前面的登录数据","slug":"_2-2、后面的请求使用了前面的登录数据","link":"#_2-2、后面的请求使用了前面的登录数据","children":[]},{"level":3,"title":"2-3、多个系统权限问题","slug":"_2-3、多个系统权限问题","link":"#_2-3、多个系统权限问题","children":[]},{"level":3,"title":"2-4、其它","slug":"_2-4、其它","link":"#_2-4、其它","children":[]}]},{"level":2,"title":"三、完美的解决方案","slug":"三、完美的解决方案","link":"#三、完美的解决方案","children":[{"level":3,"title":"3-1、common","slug":"_3-1、common","link":"#_3-1、common","children":[]},{"level":3,"title":"3-2、service","slug":"_3-2、service","link":"#_3-2、service","children":[]},{"level":3,"title":"3-3、client","slug":"_3-3、client","link":"#_3-3、client","children":[]}]},{"level":2,"title":"四、其它","slug":"四、其它","link":"#四、其它","children":[{"level":3,"title":"4-1、代码","slug":"_4-1、代码","link":"#_4-1、代码","children":[]},{"level":3,"title":"4-2、关于单点登录","slug":"_4-2、关于单点登录","link":"#_4-2、关于单点登录","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":5.9,"words":1770},"filePathRelative":"19场景题/01功能实践/基于ThreadLocal和JWT登录的问题，微服务登录架构解决方案.md","localizedDate":"2022年5月23日","excerpt":"<br>\\n<p><a href=\\"https://www.bilibili.com/video/BV1f3411G7xk\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://www.bilibili.com/video/BV1f3411G7xk</a></p>\\n<br>\\n<p>公司之前是以JWT + ThreadLocal 做的登录系统，在使用的过程发现了如下的问题，下面我们一起来看看，后面也会给出更好的解决方案。</p>\\n<br>\\n<h2>一、基于JWT + ThreadLocal实现登录</h2>\\n<br>\\n<h3>1-1、JWT</h3>","autoDesc":true}');export{k as comp,E as data};
